<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>My Blog | 第一次与vue亲密接触的挖坑和填坑之路</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/my-blog/assets/css/6.styles.82b7abc1.css" as="style"><link rel="preload" href="/my-blog/assets/js/app.094f3970.js" as="script"><link rel="preload" href="/my-blog/assets/js/1.144071f2.js" as="script"><link rel="prefetch" href="/my-blog/assets/js/0.54cb5d87.js"><link rel="prefetch" href="/my-blog/assets/js/2.c220e221.js"><link rel="prefetch" href="/my-blog/assets/js/3.d8f5a287.js"><link rel="prefetch" href="/my-blog/assets/js/4.84c480bc.js"><link rel="prefetch" href="/my-blog/assets/js/5.b5f4a675.js">
    <link rel="stylesheet" href="/my-blog/assets/css/6.styles.82b7abc1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/my-blog/" class="home-link router-link-active"><!----><span class="site-name">
      My Blog
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/my-blog/" class="nav-link">Home</a></div><div class="nav-item"><a href="/my-blog/guide/" class="nav-link">Guide</a></div><div class="nav-item"><a href="https://vuepress.vuejs.org/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><!----></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/my-blog/" class="nav-link">Home</a></div><div class="nav-item"><a href="/my-blog/guide/" class="nav-link">Guide</a></div><div class="nav-item"><a href="https://vuepress.vuejs.org/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><!----></nav><ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>JavaScript</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>CSS</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>Vue</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/my-blog/blog/vue/" class="active sidebar-link">第一次与vue亲密接触的挖坑和填坑之路</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="第一次与vue亲密接触的挖坑和填坑之路"><a href="#第一次与vue亲密接触的挖坑和填坑之路" aria-hidden="true" class="header-anchor">#</a> 第一次与vue亲密接触的挖坑和填坑之路</h1><h3 id="_1-vuex以及本地存储localstorage如何实现登录之后在刷新的时候登录状态仍然在。"><a href="#_1-vuex以及本地存储localstorage如何实现登录之后在刷新的时候登录状态仍然在。" aria-hidden="true" class="header-anchor">#</a> 1. vuex以及本地存储localStorage如何实现登录之后在刷新的时候登录状态仍然在。</h3><blockquote><p>借鉴这篇回答：<a href="https://segmentfault.com/q/1010000012065855" target="_blank" rel="noopener noreferrer">如何使用localStorage结合Vuex来保存用户登录信息?<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote><p>遇到问题——当时是期待根据localStorage中的值的改变在计算属性中随时得到新的值。事实上。vue中的值并不会因为localStorage中值的改变而变化的，触发不了。所以完美的办法就是所有和localStorage相关的都在vuex中处理，这样状态就可以实时改变了。</p><p>当时我的问题是——我想每次进入页面后检测现在localStorage中是否有登录的信息，有的话就从localStorage中取，没有的话从vuex中取，这步其实就是等待登录后拿到值，然后在我退出登录时，我清空localStorage里面的值，此时就不能进行一些操作或者一些显示。。。。我是在计算属性中获取的。</p><p>后来借鉴上文的回答，一进入页面触发vuex，去把localStorage中的值给vuex中的状态值，然后在组件中只是用状态值就行。所有localStorage的设置值和移除值均在vuex中完成。</p><p>整个处理方式就是这样的，很重要，要记住。由于项目在后面改变了方式，所以我又改变了不再使用localStorage来储存值了。</p><div class="language- extra-class"><pre class="language-text"><code>//一进入页面
created(){
    this.getLocalData();
},
methods:{
	...mapActions({
	    getLocalData:'getLocalData',
	}),
}
//vuex中
getLocalData({commit}){
    commit(types.GET_LOCALDATA);
},

[types.GET_LOCALDATA] (state){
    if(localStorage.id)
		state.sfz = localStorage.sfz;
		state.user = localStorage.id;
		state.pwd = localStorage.pwd;
		state.loginFlag = false;
	}
	
},
//退出登录
[types.LOGIN_OUT] (state){
	localStorage.removeItem('id');
	localStorage.removeItem('sfz');
	localStorage.removeItem('pwd');
	state.user = '';
	state.sfz ='';
	state.pwd ='';
	state.loginFlag = true;
	
},
</code></pre></div><h3 id="_2-computed-property-digitalcert-was-assigned-to-but-it-has-no-setter-报错"><a href="#_2-computed-property-digitalcert-was-assigned-to-but-it-has-no-setter-报错" aria-hidden="true" class="header-anchor">#</a> 2. Computed property &quot;digitalCert&quot; was assigned to but it has no setter 报错</h3><p>问题分析： 一个计算属性，如果没有设置 setter,也就是传入的是一个函数，或者传入的对象里没有 set 属性，当你尝试直接该改变这个这个计算属性的值，都会报这个错误。</p><p>在此项目中，我写了:</p><div class="language- extra-class"><pre class="language-text"><code>mounted() {
var _this = this;
document.onkeydown=function(e) {
    if(e &amp;&amp; e.keyCode==81 &amp;&amp; e.ctrlKey ){   //同时按下ctrl+q
        _this.digitalCert = false;   
}
           
</code></pre></div><p>所以更改为以下：</p><div class="language- extra-class"><pre class="language-text"><code>computed:{
    digitalCert:{
        get:function(){
            return this.$store.state.login.digitalCert;
        },
        set:function(newValue){
            this.$store.state.login.digitalCert = newValue;
        }
    }
},
</code></pre></div><h3 id="_3-在引入mapstate的计算属性时，怎么写普通的计算属性，以及设置getter和setter的计算属性："><a href="#_3-在引入mapstate的计算属性时，怎么写普通的计算属性，以及设置getter和setter的计算属性：" aria-hidden="true" class="header-anchor">#</a> 3.### 在引入mapState的计算属性时，怎么写普通的计算属性，以及设置getter和setter的计算属性：</h3><p><strong>有getter和setter</strong>：</p><div class="language- extra-class"><pre class="language-text"><code>computed:{
    digitalCert:{
        get:function(){
            return this.$store.state.login.digitalCert;
        },
        set:function(newValue){
            this.$store.state.login.digitalCert = newValue;
        }
    },
    ...mapState({
        loginBoxFlag: state =&gt; state.login.loginBoxshow,
        tipsTxt: state =&gt; state.login.tipsTxt,
    }),
},
</code></pre></div><p><strong>普通计算属性</strong>：</p><div class="language- extra-class"><pre class="language-text"><code>// mapState 辅助函数帮助我们生成计算属
computed: mapState({
    // 箭头函数可使代码更简练
    count: state =&gt; state.count,
    // 传字符串参数 'count' 等同于 'state =&gt; state.count'
    countAlias: 'count',
    // 为了能使用 'this'获取局部状态，必须使用常规函数
    countPlusLocalState (state) {
        return state.count + this.localCount
    },
    // 常规 computed, 没有使用 store的状态
    localCountAlias () {
        return this.localCount
    }
})
</code></pre></div><h3 id="_4-vuex中的请求写成promise格式的好处。"><a href="#_4-vuex中的请求写成promise格式的好处。" aria-hidden="true" class="header-anchor">#</a> 4.vuex中的请求写成promise格式的好处。</h3><p>在vuex的action里面的请求要写成promise的形式。举例如我所做的logout。事实上登录的很多状态我也可以不在vuex里面维护的，没有必要，一开始不明白这个道理：</p><div class="language- extra-class"><pre class="language-text"><code>//在header.vue中点击按钮触发logout方法
logout() {
	let _this  = this;
	this.$confirm('你确定要注销登录吗?', '提示', {
  		confirmButtonText: '确定',
  		cancelButtonText: '取消',
  		type: 'warning'
    }).then(() =&gt; {
    	_this.$store.dispatch('loginOut')
    }).then(() =&gt;{
    	_this.searchValue = '';//就可以这样清除本组件中的值，不需要去vuex中实现
    	_this.$message({
		  	type: 'success',
		  	message: '你已经成功退出登录'
		});
    }).catch((e) =&gt; {
      	this.$message({
        	type: 'info',
       		message: '已取消注销登录'
      	});          
    });
  }
</code></pre></div><p>在vuex中维护：</p><div class="language- extra-class"><pre class="language-text"><code>//actions中：
loginOut:({dispatch,commit})=&gt; {
	return new Promise((resolve, reject) =&gt; {
		utils.MlTools.ajax({
    		type:'get',
    		url:'/qbeq/userLogOut',
    		success:function(datas){
    			if(datas.code){
					commit(types.LOGIN_OUT)
					resolve(datas)
    			}
    				
    		},
    		error:function(res){
    			console.log(res)
    			reject(datas)
    		}
    	})
		
	})
}

//在mutations中：
[types.LOGIN_OUT] (state){
	state.user = '';
	state.sfz ='';
	state.pwd ='';
	state.loginFlag = true;
	
},

</code></pre></div><p>重点就想说明在actions中resolve()之后，在vue组件的then之后即为退出成功的处理了。</p><h3 id="_5-数组初始化在data中而非在computed中；数组的更新必须vue-set"><a href="#_5-数组初始化在data中而非在computed中；数组的更新必须vue-set" aria-hidden="true" class="header-anchor">#</a> 5. 数组初始化在data中而非在computed中；数组的更新必须vue.set</h3><p>初始化data之后，要在请求中对这个数进行赋值，那么不能在computed中初始化，比如将这个数组的每一个元素都初始化为0；</p><div class="language- extra-class"><pre class="language-text"><code>data (){
    return {
        trendValueIn:new Array(10).join(&quot;,&quot;).split(&quot;,&quot;).map((item,index) =&gt; {return 0;}),
        trendValueOut:new Array(10).join(&quot;,&quot;).split(&quot;,&quot;).map((item,index) =&gt; {return 0;}),
    }
   
},
computed:{
    // trendValueIn(){
    //     return new Array(10).join(&quot;,&quot;).split(&quot;,&quot;).map((item,index) =&gt; {return 0;})
    // },
    // trendValueOut(){
    //     return new Array(10).join(&quot;,&quot;).split(&quot;,&quot;).map((item,index) =&gt; {return 0;})
    // },
},
created(){
    this.reqRrendValue()
},
methods:{
    reqRrendValue(){
        let _this = this;
        this.utils.MlTools.ajax({
            url: '/qbeq/keyperson',
            type: 'post',
            data: {},
            success(data){
                _this.createdtable(data.currDay);
                _this.drawLine(data.totalDay);
            },
            error(err){
                reject(err.message)
            }
        })
    },
    createdtable(data){
        let _this = this;
        
        //今日流入
        let todayDataIn = data.filter((n,m) =&gt; {
            if(n.flag == 1){
                return n;
            }
        })
        //今日流出
        let todayDataOut = data.filter((n,m) =&gt; {
            if(n.flag == 0){
                return n;
            }
        })
        //总共的
        let totalIn = 0,totalOut = 0;
        todayDataIn.forEach((item,index) =&gt; {
            let i = _this.theader.findIndex((value,index) =&gt; {
                return value == item.type;
            })
            totalIn += item.num; 
            // _this.trendValueIn[i] = item.num;
            _this.$set(_this.trendValueIn,i-1,item.num)//更新数组需要使用vue.set
        })
        _this.$set(_this.trendValueIn,9,totalIn)
    
        todayDataOut.forEach((item,index) =&gt; {
            let i = _this.theader.findIndex((value,index) =&gt; {
                return value == item.type;
            })
            totalOut += item.num; 
            // _this.trendValueOut[i] = item.num;
            _this.$set(_this.trendValueOut,i-1,item.num)//更新数组需要使用vue.set
        })
        _this.$set(_this.trendValueOut,9,totalOut)
    },
}
</code></pre></div><h3 id="_6-vue中定时器的处理"><a href="#_6-vue中定时器的处理" aria-hidden="true" class="header-anchor">#</a> 6. vue中定时器的处理</h3><p>####（1）一进入页面触发定时器定时发起请求</p><div class="language- extra-class"><pre class="language-text"><code>mounted(){
    let _this = this;
    let timeInterval = 10000;//10s
    this.$nextTick(function(){
        _this.timer = setInterval(function(){
            // console.log(new Date())
            _this.reqRrendValue()

        },timeInterval)
        
    })
}
</code></pre></div><h4 id="_2-离开此标签页的时候，清除定时器，返回此标签页时再启动"><a href="#_2-离开此标签页的时候，清除定时器，返回此标签页时再启动" aria-hidden="true" class="header-anchor">#</a> (2) 离开此标签页的时候，清除定时器，返回此标签页时再启动</h4><blockquote><p>监测 <code>visibilitychange</code>事件</p></blockquote><div class="language- extra-class"><pre class="language-text"><code>mounted(){

    window.addEventListener(&quot;visibilitychange&quot;,()=&gt;{
        // debugger;
        if(document.hidden){
            console.log(&quot;我暂时离开页面了&quot;);
            clearInterval(_this.timer);
        }else{
            _this.timer = setInterval(function(){
                // console.log(new Date())
                _this.reqRrendValue()

            },timeInterval)
        }
        
   })
    
},
</code></pre></div><h4 id="（3）-在可视区域时启动定时器，不在时清除定时请求"><a href="#（3）-在可视区域时启动定时器，不在时清除定时请求" aria-hidden="true" class="header-anchor">#</a> （3） 在可视区域时启动定时器，不在时清除定时请求</h4><div class="language- extra-class"><pre class="language-text"><code>let _this = this;
let timeInterval = 10*1000;//10s

// 由于我的定时器在一进入页面的时候，不在可视区域内，所以不用启动定时器，这块存在无作用
//this.$nextTick(function(){
//     if(isElementInViewport(document.getElementsByClassName(&quot;trend&quot;)[0])){
//             _this.timer = setInterval(function(){
//                 console.log(11111)
//                 console.log(new Date())
//                 _this.reqRrendValue()

//             },timeInterval) 
//         }else{
//             console.log(&quot;不在可视区域，清除定时请求&quot;);
//             clearInterval(_this.timer);
//         }
    
// })

window.addEventListener(&quot;visibilitychange&quot;,() =&gt; {
    clearInterval(_this.timer);
    if(document.hidden){
        console.log(&quot;我暂时离开页面了&quot;);
        clearInterval(_this.timer);
    }else{
       if(isElementInViewport(document.getElementsByClassName(&quot;trend&quot;)[0])){
            _this.timer = setInterval(function(){
                console.log(2222222)
                console.log(new Date())
                _this.reqRrendValue()

            },timeInterval) 
        }else{
            console.log(&quot;不在可视区域,清除定时请求&quot;);
            clearInterval(_this.timer);
        }
    }
})

//监测滚动事件
window.addEventListener(&quot;scroll&quot;,() =&gt;{
    clearInterval(_this.timer);
    console.log(isElementInViewport(document.getElementsByClassName(&quot;trend&quot;)[0]));
    if(isElementInViewport(document.getElementsByClassName(&quot;trend&quot;)[0])){
        _this.timer = setInterval(function(){
            console.log(333333)
            console.log(new Date())
            _this.reqRrendValue()

        },timeInterval) 
    }else{
        console.log(&quot;不在可视区域，清除定时请求&quot;);
        clearInterval(_this.timer);
    }
})

//元素是否在可视区域内
function isElementInViewport (el, offset = 23) {
    const box = el.getBoundingClientRect(),
          top = (box.top &gt;= -25),
          left = (box.left &gt;= 0),
          bottom = (box.bottom &lt;= (window.innerHeight || document.documentElement.clientHeight) + offset),
          right = (box.right &lt;= (window.innerWidth || document.documentElement.clientWidth) + offset);

    return (top &amp;&amp; bottom&amp;&amp; left  &amp;&amp; right);
}
</code></pre></div><h4 id="（4）定时器必须在组件生命周期的destory时清除。（必须）"><a href="#（4）定时器必须在组件生命周期的destory时清除。（必须）" aria-hidden="true" class="header-anchor">#</a> （4）定时器必须在组件生命周期的destory时清除。（必须）</h4><ul><li>在本组件中写的定时器</li></ul><div class="language- extra-class"><pre class="language-text"><code>destroyed(){
    console.log(&quot;我已经离开页面了&quot;);
    clearInterval(this.timer);
},
</code></pre></div><ul><li>引入的js</li></ul><div class="language- extra-class"><pre class="language-text"><code>//在mapLoad.js中：

var scrollIntervalStart,scrollInterval;

const mapLoad = {
	....
}

export {mapLoad,scrollIntervalStart,scrollInterval}

//在map.vue中：

import {mapLoad,scrollIntervalStart,scrollInterval} from '@/common/mapLoad';

destroyed(){
	//清除地图上的滚动定时
    console.log(&quot;我已经离开页面了&quot;);
    clearInterval(scrollIntervalStart);
	clearInterval(scrollInterval);
},
</code></pre></div><h3 id="_7-自定义指令"><a href="#_7-自定义指令" aria-hidden="true" class="header-anchor">#</a> 7.自定义指令</h3><div class="language- extra-class"><pre class="language-text"><code>/**
 * 注册一个全局自定义指令 v-focus
 */
Vue.directive('focus', {
    // 当绑定元素插入到 DOM 中。
    inserted: function (el) {
        // 聚焦元素
        el.focus()
    }
})
/**
 * 注册一个全局自定义指令 v-ctrlq,按下ctrl+q时执行操作
 * 
 */
Vue.directive('ctrlq', {
    bind:function(el,binding,vnode){
        function documentHandler (e) {
            if (e &amp;&amp; e.keyCode==81 &amp;&amp; e.ctrlKey){
                if (binding.expression) {
                    binding.value(e);
                }
            }
        }
        el.__ctrlq__ = documentHandler;
        document.addEventListener('keydown',documentHandler);
    },
    unbind:function(el,binding){
        document.removeEventListener('keydown',el.__ctrlq__);
        delete el.__ctrlq__;
    }
})

/**
 * 注册一个全局自定义指令 v-clickoutside,在元素之外点击时执行函数，如点击旁边收起下拉框
 * 
 */
Vue.directive('clickoutside',{
    bind:function (el, binding, vnode) {
        function documentHandler (e){
            if (el.contains(e.target)) {
                return false;
            }
            if (binding.expression) {
                binding.value(e);
            }
        }
        el.__vueClickOutside__ = documentHandler;
        document.addEventListener('click',documentHandler);
    },
    unbind: function (el, binding){
        document.removeEventListener('click',el.__vueClickOutside__);
        delete el.__vueClickOutside__;
    }
})

</code></pre></div><h3 id="_8-vue-router-的理解"><a href="#_8-vue-router-的理解" aria-hidden="true" class="header-anchor">#</a> 8.vue-router 的理解</h3><p>vue本身起的项目一般为http://localhost:8080,也就是http://localhost:8080/index.html，我们的项目如果是简单的vue单页面应用的话，其本身就只有一个页面——index.html。而路由页就相当于加了几个hash切换，通过js动态加载其他几个页面的，所以其其实是http://localhost:8080/index.html/#/index，http://localhost:8080/index.html/#/list。</p><p>同时在服务器上，真实的页面也就只有index.html,所以使用vue-router的mode:history模式就有问题了（这个原理嘛。。。）官网上有处理办法，后端要配合进行配置才可以。</p><blockquote><p>(官网上)<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html" target="_blank" rel="noopener noreferrer">HTML5 History 模式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。
如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p><div class="language- extra-class"><pre class="language-text"><code>const router = new VueRouter({
  mode: 'history',
  routes: [...]
 })
</code></pre></div><p>当你使用 history 模式时，URL 就像正常的 url，例如 http://yoursite.com/user/id，也好看！
不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404，这就不好看了。
所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。
图片名字也都需要小写。</p></blockquote><h3 id="_9-vue-router的守卫"><a href="#_9-vue-router的守卫" aria-hidden="true" class="header-anchor">#</a> 9.vue-router的守卫</h3><p>本项目中要求在未登录之前，不能进入别的路由页，所以设置全局钩子：</p><div class="language- extra-class"><pre class="language-text"><code>const router = new Router({
	base:__dirname,
	routes:routes
})

router.beforeEach((to,from,next) =&gt; {
	if(to.meta.requireAuth){
		if(store.state.login.user){
			next()
		}else{
			next({path:'/index'})
			store.commit('LOGIN_BOX',true)
		}
	}else{
		next();
	}
})
</code></pre></div><p>官网上————<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%AE%88%E5%8D%AB" target="_blank" rel="noopener noreferrer">导航守卫<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><strong>路由单个守卫：</strong></p><div class="language- extra-class"><pre class="language-text"><code>const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) =&gt; {
        // ...
      }
    }
  ]
})
</code></pre></div><p><strong>组件内的守卫</strong>：</p><div class="language- extra-class"><pre class="language-text"><code>const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  }
}
</code></pre></div><h4 id="完整的导航解析流程"><a href="#完整的导航解析流程" aria-hidden="true" class="header-anchor">#</a> 完整的导航解析流程</h4><ul><li>导航被触发。</li><li>在失活的组件里调用离开守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 beforeRouteEnter</li><li>守卫中传给 next 的回调函数。</li></ul><h3 id="_10-vue中获取input的type"><a href="#_10-vue中获取input的type" aria-hidden="true" class="header-anchor">#</a> 10.vue中获取input的type</h3><p>聚集时改变type：</p><div class="language- extra-class"><pre class="language-text"><code>&lt;input type=&quot;text&quot; ref=&quot;pwd&quot; v-model=&quot;rgform.rgpwd&quot; placeholder=&quot;请输入密码&quot; @focus=&quot;changeType&quot;&gt;

changeType(e){
    e.target.type = 'password';
},

//或者：
this.$refs.pwd.type
</code></pre></div><h3 id="_11-vue中实现密码可见不可见"><a href="#_11-vue中实现密码可见不可见" aria-hidden="true" class="header-anchor">#</a> 11.vue中实现密码可见不可见</h3><div class="language- extra-class"><pre class="language-text"><code>&lt;input type=&quot;password&quot; v-model=&quot;rgform.rgpwd&quot; ref=&quot;rgspwd&quot; placeholder=&quot;请输入密码&quot; v-if=&quot;viewFlag&quot;&gt;
&lt;input type=&quot;text&quot; v-model=&quot;rgform.rgpwd&quot; ref=&quot;rgspwd&quot; placeholder=&quot;请输入密码&quot; v-else&gt;&lt;i class=&quot;el-eye&quot; @click=&quot;changeView&quot;&gt;&lt;/i&gt;

</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>changeView(){
    this.viewFlag=false;
}
</code></pre></div><h3 id="_12-for循环上需要有key标志，标志唯一性，否则报warning。"><a href="#_12-for循环上需要有key标志，标志唯一性，否则报warning。" aria-hidden="true" class="header-anchor">#</a> 12.for循环上需要有key标志，标志唯一性，否则报warning。</h3><div class="language- extra-class"><pre class="language-text"><code>&lt;el-option  v-for=&quot;item in protalOptions&quot; :label=&quot;item.name&quot; :key=&quot;item.id&quot; :value=&quot;item.id&quot;&gt;&lt;/el-option&gt;
</code></pre></div><h3 id="_13-vue中title图标的添加"><a href="#_13-vue中title图标的添加" aria-hidden="true" class="header-anchor">#</a> 13.vue中title图标的添加</h3><p>在webpack.dev.conf.js中：</p><div class="language- extra-class"><pre class="language-text"><code> new HtmlWebpackPlugin({
  filename: 'index.html',
  template: 'index.html',
  inject: true,
  favicon:'./favicon.ico'
}),
</code></pre></div><p>同时生产环境中，在webpack.prod.conf.js中：</p><div class="language- extra-class"><pre class="language-text"><code>new HtmlWebpackPlugin({
  filename: config.build.index,
  template: 'index.html',
  inject: true,
  favicon: './favicon.ico',
  minify: {
    removeComments: true,
    collapseWhitespace: true,
    removeAttributeQuotes: true
    // more options:
    // https://github.com/kangax/html-minifier#options-quick-reference
  },
</code></pre></div><h3 id="_14-ie11中打开vue项目页面一片空白"><a href="#_14-ie11中打开vue项目页面一片空白" aria-hidden="true" class="header-anchor">#</a> 14.ie11中打开vue项目页面一片空白</h3><p><a href="https://blog.csdn.net/bright2017/article/details/77850525" target="_blank" rel="noopener noreferrer">Vue2.0做的项目在IE11下面打开一片空白？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>安装 &quot;babel-polyfill&quot; 即可。
在入口main.js文件引入：import 'babel-polyfill'
在webpack.base.conf.js中，</p><div class="language- extra-class"><pre class="language-text"><code>module.exports = {
	entry: {
		app: [&quot;babel-polyfill&quot;, &quot;./src/main.js&quot;]
	}
},
</code></pre></div><h3 id="_15-为何vue不支持ie8"><a href="#_15-为何vue不支持ie8" aria-hidden="true" class="header-anchor">#</a> 15.为何vue不支持IE8</h3><p>（https://blog.csdn.net/csdn_yudong/article/details/78332665）
因为 Vue.js 使用了 IE8 不能模拟的 ECMAScript 5 特性。</p><p>但具体是哪些特性呢？</p><p><code>Object.defineProperty()</code>
该方法允许精确添加或修改对象的属性。一般情况下，我们为对象添加属性是通过赋值来创建并显示在属性枚举中（for…in 或 Object.keys 方法），但这种方式添加的属性值可以被改变，也可以被删除。而使用 <code>Object.defineProperty()</code> 则允许改变这些额外细节的默认设置。例如，默认情况下，使用 <code>Object.defineProperty()</code>增加的属性值是不可改变的。</p><h3 id="_16-vue的js中的动态html中的img的src写法"><a href="#_16-vue的js中的动态html中的img的src写法" aria-hidden="true" class="header-anchor">#</a> 16.vue的js中的动态html中的img的src写法</h3><p>只要在script中的都需要用require()的格式加载图片</p><div class="language- extra-class"><pre class="language-text"><code>var contentHtml = `&lt;div class=&quot;popWrap&quot;&gt;
    &lt;div class=&quot;popTop&quot;&gt;
        &lt;div class=&quot;imgBox&quot;&gt;
            &lt;img src=${require(&quot;@/images/portait.jpg&quot;)}&gt;
        &lt;/div&gt;
        &lt;ul class=&quot;infoRight&quot;&gt;
            &lt;li&gt;&lt;label&gt;姓&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;名:&lt;/label&gt;&lt;span&gt;${cfeature.get('person_name')}&lt;/span&gt;
            &lt;div class=&quot;hrefs&quot;&gt;&lt;a title=&quot;到档案&quot; class=&quot;popArchives&quot; data-card=&quot;${cfeature.get('person_card')}&quot;&gt;&lt;/a&gt;
            &lt;/div&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;div class=&quot;closePopup&quot;&gt;
        &lt;span&gt;x&lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;`;
overlay.setPosition(undefined);
if(overlay.getPosition() == undefined){
    overlay.setPosition(cfeature.get('center'));
    map.getView().setCenter(cfeature.get('center'));
}

map.addOverlay(overlay);
$(&quot;#popup&quot;).html(contentHtml);
</code></pre></div></div><div class="content edit-link"><!----><!----></div><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/my-blog/blog/css/" class="prev">
          更换&lt;input type=&quot;checkbox&quot;&gt;的样式
        </a></span><!----></p></div></div></div></div>
    <script src="/my-blog/assets/js/1.144071f2.js" defer></script><script src="/my-blog/assets/js/app.094f3970.js" defer></script>
  </body>
</html>
