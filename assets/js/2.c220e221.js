(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{148:function(n,t,e){"use strict";e.r(t);var a=e(0),s=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"es6编程风格"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es6编程风格","aria-hidden":"true"}},[n._v("#")]),n._v(" es6编程风格")]),e("h3",{attrs:{id:"_1-使用let替换var"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-使用let替换var","aria-hidden":"true"}},[n._v("#")]),n._v(" 1. 使用let替换var")]),e("h3",{attrs:{id:"_2-建议优先使用const"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-建议优先使用const","aria-hidden":"true"}},[n._v("#")]),n._v(" 2. 建议优先使用const")]),e("p",[n._v("尤其是在全局环境，不应该设置变量，只应设置常量。")]),e("p",[e("strong",[n._v("const优于let有几个原因:")])]),e("ul",[e("li",[n._v("const可以提醒阅读程序的人，这个变量不应该改变；")]),e("li",[n._v("const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；")]),e("li",[n._v("JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同")])]),e("h3",{attrs:{id:"_3-对象尽量静态化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-对象尽量静态化","aria-hidden":"true"}},[n._v("#")]),n._v(" 3.对象尽量静态化")]),e("p",[n._v("一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用"),e("code",[n._v("Object.assign")]),n._v("方法。")]),e("h3",{attrs:{id:"_4-箭头函数取代function-prototype-bind，不应再用-self-this-that-绑定-this。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-箭头函数取代function-prototype-bind，不应再用-self-this-that-绑定-this。","aria-hidden":"true"}},[n._v("#")]),n._v(" 4.箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this。(?)")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// bad\nconst self = this;\nconst boundMethod = function(...params) {\n  return method.apply(self, params);\n}\n\n// acceptable\nconst boundMethod = method.bind(this);\n\n// best\nconst boundMethod = (...params) => method.apply(this, params);\n")])])]),e("h3",{attrs:{id:"_4-使用export取代module-exports。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-使用export取代module-exports。","aria-hidden":"true"}},[n._v("#")]),n._v(" 4.使用export取代module.exports。")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// commonJS的写法\nvar React = require('react');\n\nvar Breadcrumbs = React.createClass({\n  render() {\n    return <nav />;\n  }\n});\n\nmodule.exports = Breadcrumbs;\n\n// ES6的写法\nimport React from 'react';\n\nclass Breadcrumbs extends React.Component {\n  render() {\n    return <nav />;\n  }\n};\n\nexport default Breadcrumbs;\n")])])]),e("p",[n._v("不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// bad\nimport * as myObject from './importModule';\n\n// good\nimport myObject from './importModule';\n")])])]),e("p",[n._v("如果模块默认输出一个对象，对象名的首字母应该大写。")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const StyleGuide = {\n  es6: {\n  }\n};\n\nexport default StyleGuide;\n")])])]),e("h3",{attrs:{id:"_5-其他部分从下面代码中学习"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-其他部分从下面代码中学习","aria-hidden":"true"}},[n._v("#")]),n._v(" 5.其他部分从下面代码中学习")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//静态字符串使用单引号，动态使用反引号\nconst ad = 'foo';\nconst bd= `qwe${ad}`;\nconsole.log(bd);//qwefoo\n\n//数组解构赋值\nconst arr = [1,2,3];\n\nconst [first,second] = arr;\n\nconsole.log(first);//1\nconsole.log(second);//2\n\n//对象解构赋值，必须变量名和属性名一致，没有次序\nconst obj = {\n\tfirstName:\"zhang\",\n\tsecondName:'san'\n}\n\ngetNameVal(obj)//zhangsan\n\ngets(obj)//zhangsan\n\nfunction getNameVal({firstName,secondName}){\n\tconsole.log(firstName + secondName);\n}\nfunction gets(obj){\n\tconst {secondName,firstName} = obj;\n\tconsole.log(firstName + secondName);\n}\n\n//函数返回多个值，优先考虑对象解构\nfunction sets(input){\n\tlet a = input == 1 ? 'a1':'';\n\tlet b = input == 1 ? 'b1':'';\n\tlet c = input == 1 ? 'c1':'';\n\treturn {a,b,c};\n}\n\nconst {a,b,c} = sets(1);\nconsole.log(a + b + c);//a1b1c1\n\n//创建对象时属性名使用属性表达式定义。方法使用简写\nconst obgj = {\n\tm:1,\n\tn:2,\n\t[sets(1)['a']]:true,\n\tadd(j,k) {\n\t\treturn obgj.m +j +k;\n\t}\n}\nconsole.log(obgj);//{m:1,n:2,a1:true,add:f}\nconsole.log(obgj.add(3,1));//5\n\n//扩展运算符复制数组，不影响原数组\nconst arr1 = [...arr];\nconsole.log(arr1);//[1,2,3]\narr1.push(9);\nconsole.log(arr);//[1,2,3]\nconsole.log(arr1);//[1,2,3,9]\n\n// 使用 Array.from 方法，将类似数组的对象转为数组。\nconst foo = document.querySelectorAll('.foo');\nconst nodes = Array.from(foo);\nconsole.log(Array.isArray(nodes));//true\n\n\n//配置项以对象形式放在最后一位，false不能直接作为参数\nfunction render(a,b,{p = false } = {}){\n\tconsole.log(a);//1\n\tconsole.log(b);//2\n\tconsole.log(p);//{age:1,height:23}\n}\nrender(1,2,{p:{age:1,height:23}});//{age:1,height:23}\n\n//使用rest运算符(...)代替arguments,提供一个真正的数组\nfunction add(...arg){\n\treturn arg.reduce((val,k) => {\n\t\treturn  val = val + k;\n\t})\n}\nconsole.log(add(1,2,3,4));//10\n\n//对象到Map需要进行转换，Map只是对于值到值好用，需要set给里面加，然后再遍历\nlet o = sets(1);\n\nfunction objToMap(obj){\n\tlet map = new Map();\n\tfor (let k of Object.keys(obj)){\n\t\tmap.set(k,obj[k])\n\t}\n\treturn map\n}\nlet map = new Map(objToMap(o)) ;\n\nfor(let value of map.values()){\n\tconsole.log(value);//a1 /n a2 /n a3\n}\n")])])])])}],!1,null,null,null);t.default=s.exports}}]);